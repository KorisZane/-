## \==和===

php是一个弱语言

\==是一个弱比较，使用\==进行对比的时候，php会进行隐形转换，两个值类型不同会转换成相同的类型再比较

```
<?php  
$type = intval(@$_GET['type']);  
if($type == 'pay'){  
    echo 'ok';  
}else{  
    echo 'error';  
}
```

type传参0，payx 都打印ok

## MD5缺陷

进行hash加密出来的字符串如存在0e开头进行弱比较的话会直接判定为true

```
QNKCDZO

0e830400451993494058024219903391

240610708

0e462097431906509019562988736854

s878926199a

0e545993274517709034328855841020

s155964671a

0e342768416822451524974117254469

s214587387a

0e848240448830537924465865611904

s214587387a

0e848240448830537924465865611904

s878926199a

0e545993274517709034328855841020

s1091221200a

0e940624217856561557816327384675

s1885207154a

0e509367213418206700842008763514
```

```
<?php  
$a = @$_GET['a'];  
$passwd='0e848240448830537924465865611904';  
if(md5($a)==$passwd){  
    echo "进入后台";  
}
```

md5加密后0e格式科学计数法弱类型比较都相等

## 函数strcmp比较缺陷

低版本的strcmp比较的是字符串类型，如果强行传入其他类型参数，会出错，出错后返回值0，正是利用这点进行绕过

```
<?php  
$passwd="********";  
if(isset($_POST["passwd"])){  
    if(strcmp($_POST["passwd"],$passwd)==0){  
        echo "进入后台";  
        exit;  
    }  
    else{  
        echo "wrong password";  
    }  
}
```

传参passed[]=xxxx 5版本及之前可以绕过

## 函数Bool类型比较缺陷

在使用 json_decode() 函数或 unserialize() 函数时，部分结构被解释成 bool 类型，也会造成缺陷，运行结果超出研发人员的预期

```
<?php  
$str=@$_REQUEST['str'];  
$data=json_decode($str);  
if($data['user']=='qiyi' && $data['pass']=='123456'){  
    echo "登陆成功";  
}else{  
    echo "登陆失败";  
}
```

str传参{"user":true,"pass":true}可进行绕过

## 函数switch 类型比较缺陷

当在switch中使用case判断数字时，switch会将参数转换为int类型计算

## 函数in_array数组比较缺陷

当使用in_array()或array_search()函数时，如果第三个参数没有设置为true，则in_array()或array_search()将使用松散比较来判断

## \==\=数组比较缺陷

注意此时遇到的是 “\=\==” ，不过也不是代表无从下手。在md5()函数传入数组时会报错返回NULL，当变量都导致报错返回NULL时就能使得条件成立。

***上述安全问题实际审计几乎碰不到，多为CTF题型，与传统学校教学一样，偏学术***

***语言不是为安全服务，上述问题是为了高效，php作为高级语言的特性***



